#Copyright (c) Microsoft. All rights reserved.
#Licensed under the MIT license. See LICENSE file in the project root for full license information.

# Find dumpbin - first check DUMPBIN_PATH env var (set by discover_native_tools.yml),
# then PATH, then discover via vswhere
function Get-DumpbinPath {
    # Check environment variable first (set by pipeline)
    if ($env:DUMPBIN_PATH -and (Test-Path $env:DUMPBIN_PATH)) {
        return $env:DUMPBIN_PATH
    }
    
    # Try to find dumpbin in PATH
    $dumpbin = Get-Command "dumpbin.exe" -ErrorAction SilentlyContinue
    if ($dumpbin) {
        return $dumpbin.Path
    }
    
    # Use vswhere to find VS installation
    $vswhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
    if (-not (Test-Path $vswhere)) {
        # Try Program Files for ARM64
        $vswhere = "${env:ProgramFiles}\Microsoft Visual Studio\Installer\vswhere.exe"
    }
    
    if (Test-Path $vswhere) {
        $vsPath = & $vswhere -latest -products * -property installationPath 2>$null
        if ($vsPath) {
            # Find MSVC tools directory
            $vcToolsDir = Join-Path $vsPath "VC\Tools\MSVC"
            if (Test-Path $vcToolsDir) {
                # Get the latest version
                $versions = Get-ChildItem $vcToolsDir -Directory | Sort-Object Name -Descending
                foreach ($version in $versions) {
                    # Try native host architecture first
                    $arch = $env:PROCESSOR_ARCHITECTURE
                    if ($arch -eq "ARM64") {
                        $hostArch = "Hostarm64\arm64"
                    } elseif ($arch -eq "AMD64") {
                        $hostArch = "Hostx64\x64"
                    } else {
                        $hostArch = "Hostx86\x86"
                    }
                    
                    $dumpbin = Join-Path $version.FullName "bin\$hostArch\dumpbin.exe"
                    if (Test-Path $dumpbin) {
                        return $dumpbin
                    }
                    
                    # Fallback to x64
                    $dumpbin = Join-Path $version.FullName "bin\Hostx64\x64\dumpbin.exe"
                    if (Test-Path $dumpbin) {
                        return $dumpbin
                    }
                }
            }
        }
    }
    
    return $null
}

# Get dumpbin path once for all checks
$script:dumpbinPath = Get-DumpbinPath
if (-not $script:dumpbinPath) {
    Write-Error "Unable to find dumpbin.exe. Ensure Visual Studio is installed or DUMPBIN_PATH is set."
    exit 2
}
Write-Host "Using dumpbin: $script:dumpbinPath"

function Check-Symbols {
    param(
        [string] $lib
    )   
    try {
        [string]$output = cmd.exe /c "`"$script:dumpbinPath`" /ALL `"$lib`""
    }
    catch {
        Write-Error  "Unable to run dumpbin on given lib $lib"
        return 2
    }

    # The list of public symbols in the dumpbin output is contained between these two symbols:
    $start_token = "public symbols"
    $end_token = "Archive member name"
    try {
        [int] $start = $output.IndexOf($start_token)
        [int] $end = $output.IndexOf($end_token, $start)

        # Isolating symbols from rest of dumpbin output
        $symbol_text = ($output.Substring($start + $start_token.Length+1, $end-$start-$start_token.Length-1))
        
        # Splitting text by whitespace, alternate tokens are symbols
        $split_symbols = $symbol_text.Split('',[StringSplitOptions]::RemoveEmptyEntries)
    }
    catch {
        Write-Error  "Unable to parse dumpbin output for lib $lib"
        return 2
    }
    # Detecting if symbol list was not generated by dumpbin
    if($split_symbols.Length -lt 2) {
        Write-Error  "Unable to parse dumpbin output for lib $lib"
        return 2
    }
    
    $real_prefix = "real_"

    # hashset to store original symbols and real symbols
    $symbol_table = New-Object -TypeName "System.Collections.Generic.HashSet[string]"

    # list of symbols that have original and duplicate. 
    $duplicate_symbols = New-Object -TypeName "System.Collections.ArrayList"

    $return_code = 0
    for($i=0; $i -lt $split_symbols.Length; $i++){
        # Skip even tokens because only odd tokens have symbols
        if($i % 2 -ne 0) {
            if($split_symbols[$i].StartsWith($real_prefix)) {
                $real_symbol = $split_symbols[$i]
                $symbol = $split_symbols[$i].Substring($real_prefix.Length)
            } else {
                $symbol = $split_symbols[$i]
                $real_symbol = $real_prefix + $symbol
            }
            # Add original symbol and real symbol to hashset
            if(-not ($symbol_table.Add($symbol) -and $symbol_table.Add($real_symbol))){
                # If either of the adds fails, it means symbol was already present in hashset
                $return_code = 1
                [void]$duplicate_symbols.Add($symbol)
            }
        }
    }
    # Print duplicate symbols (if any) to stderr
    if($duplicate_symbols.Count -gt 0){
        Write-Error ("The following symbols have original and reals:`n"+($duplicate_symbols -join "`n"))
    }
    return $return_code
}

ForEach($lib in $args){
    Write-Host "Checking lib $lib"
    try {
        $exit_code = Check-Symbols -lib $lib
    }
    catch {
        Write-Error "Unable to check lib $lib."
        return 2
    }

    if($exit_code -ne 0){
        exit $exit_code
    }
}
exit 0

<#
.SYNOPSIS

Checks library for presence of "[symbol]" and "real_[symbol]".

.DESCRIPTION

Checks library for presence of "[symbol]" and "real_[symbol]". Takes path to library as parameter.

.PARAMETER lib

Library to be checked.

.INPUTS

None.

.OUTPUTS

None. 

Returns exit code 0 if no ("[symbol]", "real_[symbol]") pairs found in any library.
Returns exit code 1 if atleast 1 ("[symbol]", "real_[symbol]") pair found in a library. Prints names of symbols to stderr.
Returns exit code 2 if unable to determine for a library. Prints reason to stderror.

.EXAMPLE

PS> .\reals_check.ps1 lib_to_check_good.lib
PS> $lastexitcode
0

.EXAMPLE

PS> .\reals_check.ps1 lib_to_check_bad.lib
Check-Symbols : The following symbols are duplicate:
[
    list of duplicate symbols
]
At {path_to_script}\reals_check.ps1:57 char:7
+ exit (Check-Symbols -lib $args[0])
+       ~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : NotSpecified: (:) [Write-Error], WriteErrorException
    + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException,Check-Symbols

PS> $lastexitcode
1

.EXAMPLE

PS> .\reals_check.ps1 lib_to_check_nonexistent.lib
Check-Symbols : Unable to parse dumpbin output
At {path_to_script}\reals_check.ps1:57 char:7
+ exit (Check-Symbols -lib $args[0])
+       ~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : NotSpecified: (:) [Write-Error], WriteErrorException
    + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException,Check-Symbols

PS> $lastexitcode
2
#>
