# Copyright (c) Microsoft. All rights reserved.
# Licensed under the MIT license. See LICENSE file in the project root for full license information.

# GitHub repository operations for propagate_updates.ps1

# Source dependencies
. "$PSScriptRoot\status_tracking.ps1"
. "$PSScriptRoot\watch_github_pr.ps1"

# update dependencies for Github repo
# Returns the PR URL for status tracking
function update-repo-github
{
    param(
        [string] $repo_name,
        [string] $new_branch_name
    )
    $fn_result = $null

    Push-Location $repo_name
    Write-Host "`nCreating PR"
    $working_directory = (Get-Location).Path
    $null = gh pr create --title "[autogenerated] update dependencies" --body "Propagating dependency updates" --head $new_branch_name

    # Get PR URL
    $pr_info = gh pr view --json url 2>&1
    if($LASTEXITCODE -eq 0)
    {
        $pr_data = $pr_info | ConvertFrom-Json
        $fn_result = $pr_data.url
    }
    else
    {
        # couldn't get PR URL
    }

    # Update status with PR URL immediately so it shows even if later steps fail
    set-repo-status -repo_name $repo_name -status $script:STATUS_IN_PROGRESS -pr_url $fn_result

    # Enable auto-merge so GitHub merges once required checks pass
    Write-Host "Enabling auto-merge"
    $null = gh pr merge --auto --squash --delete-branch 2>&1
    if($LASTEXITCODE -ne 0)
    {
        Write-Host "Warning: Could not enable auto-merge, will merge manually" -ForegroundColor Yellow
    }
    else
    {
        Write-Host "Auto-merge enabled" -ForegroundColor Green
    }

    # Small wait to ensure PR is fully created before triggering pipeline
    Start-Sleep -Seconds 30
    $null = gh pr comment --body "/AzurePipelines run"
    Write-Host "Waiting for checks to start"
    Start-Sleep -Seconds 120

    Write-Host "Waiting for build to complete"
    $watch_result = watch-github-pr-checks -poll_interval 30 -timeout 120 -OnIteration { [void](show-propagation-status) }

    # Check if PR was auto-merged
    $pr_state = gh pr view --json state 2>&1
    $merged = $false
    if($LASTEXITCODE -eq 0)
    {
        $state_data = $pr_state | ConvertFrom-Json
        if($state_data.state -eq "MERGED")
        {
            $merged = $true
            Write-Host "PR auto-merged successfully" -ForegroundColor Green
        }
        else
        {
            # PR not merged yet
        }
    }
    else
    {
        # couldn't get PR state
    }

    if(-not $merged)
    {
        # Auto-merge didn't happen â€” required checks may have failed
        if(-not $watch_result.Success)
        {
            fail-with-status "PR checks failed for repo ${repo_name}: $($watch_result.Message)"
        }
        else
        {
            # Checks passed but auto-merge hasn't triggered yet, wait and retry
            Write-Host "Waiting for auto-merge to complete..."
            $max_wait = 120
            $waited = 0
            while($waited -lt $max_wait -and -not $merged)
            {
                Start-Sleep -Seconds 15
                $waited += 15
                $pr_state = gh pr view --json state 2>&1
                if($LASTEXITCODE -eq 0)
                {
                    $state_data = $pr_state | ConvertFrom-Json
                    if($state_data.state -eq "MERGED")
                    {
                        $merged = $true
                        Write-Host "PR auto-merged successfully" -ForegroundColor Green
                    }
                    else
                    {
                        # still waiting
                    }
                }
                else
                {
                    # couldn't get PR state
                }
            }

            if(-not $merged)
            {
                fail-with-status "PR for repo $repo_name was not merged after waiting ${max_wait}s"
            }
            else
            {
                # already logged success
            }
        }
    }
    else
    {
        # already merged
    }

    # Wait for merge to settle
    Start-Sleep -Seconds 10
    Pop-Location

    return $fn_result
}
