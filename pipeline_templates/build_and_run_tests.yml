# This is the job template for building the binaries for one configuration. It does:
# - setup the machine
# - build binaries for desired configuration
# - upload binaries artifacts for the desired configuration

parameters:
  - name: BUILD_SUFFIX
    type: string
  - name: GBALLOC_LL_TYPE
    type: string
  - name: FSANITIZE_TYPE
    type: string
  - name: build_configuration
    default: "Debug"
  - name: ARCH_TYPE
    default: "x64"
  - name: cmake_options
    type: string
    default: "-Drun_reals_check:bool=ON -Drun_unittests:bool=ON -Drun_int_tests:bool=ON -Duse_cppunittest:bool=ON -Drun_traceability:BOOL=ON -Drun_repo_validation:BOOL=ON"
  # If this parameter is specified the specified test suite will be run without invoking ctest
  - name: run_test_suite_without_ctest
    type: string
    default: ""
  # Settings to add an app verifier step for ctest
  - name: with_app_verifier
    type: boolean
    default: false
  - name: repo_root_override
    default: $(Build.SourcesDirectory)/deps/c-build-tools
  - name: binary_name_suffix
    default: ".exe"
  - name: appverifier_skip_tests_list
    type: string
    default: ""
  - name: failOnMinTestsNotRun
    type: boolean
    default: true
  # ARM64 builds are optional (continueOnError) so they don't block the gate
  - name: is_optional
    type: boolean
    default: false

jobs:
- job: build_and_run_tests_${{ parameters.BUILD_SUFFIX }}
  displayName: 'Build and run tests, build_configuration: ${{ parameters.build_configuration }}, ${{ parameters.GBALLOC_LL_TYPE}}, ARCH_TYPE=${{ parameters.ARCH_TYPE }}, FSANITIZE_TYPE: ${{ parameters.FSANITIZE_TYPE}}'
  continueOnError: ${{ parameters.is_optional }}

  variables:
    ${{ if eq(parameters.FSANITIZE_TYPE, 'ON') }}:
      use_vld_option: '-Duse_vld:bool=OFF'
    ${{ if eq(parameters.FSANITIZE_TYPE, 'OFF') }}:
      use_vld_option: '-Duse_vld:bool=ON'

  # ARM64 uses dedicated ARM pool, x64 uses standard pool
  ${{ if eq(parameters.ARCH_TYPE, 'ARM64') }}:
    pool:
      name: Azure-MessagingStore-WinBuildPoolARM
      demands:
      - msbuild
      - cmake
      - visualstudio
  ${{ else }}:
    pool:
      name: Azure-MessagingStore-WinBuildPoolVS2022_0
      demands:
      - msbuild
      - cmake
      - visualstudio

  workspace:
    clean: all

  steps:
  - checkout: self
    submodules: true
    clean: false

  # ARM64: Verify agent architecture and discover native tools
  - ${{ if eq(parameters.ARCH_TYPE, 'ARM64') }}:
    - template: verify_agent_architecture.yml
      parameters:
        expected_architecture: 'ARM64'

    - template: discover_native_tools.yml
      parameters:
        architecture: 'ARM64'

  # x64/x86: Discover native tools for consistency
  - ${{ if ne(parameters.ARCH_TYPE, 'ARM64') }}:
    - template: discover_native_tools.yml
      parameters:
        architecture: ${{ parameters.ARCH_TYPE }}

  - task: BatchScript@1
    displayName: 'Git submodule update'
    inputs:
      filename: 'C:\Program Files\Git\bin\git.exe'
      arguments: 'submodule update --init --force'

  - task: BatchScript@1
    displayName: 'Git submodule clean'
    inputs:
      filename: 'C:\Program Files\Git\bin\git.exe'
      arguments: 'submodule foreach --recursive "git clean -xdff"'

  - task: BatchScript@1
    displayName: 'Git clean'
    inputs:
      filename: 'C:\Program Files\Git\bin\git.exe'
      arguments: 'clean -xdff'

  # Setup VS environment - use discovered vsPath for correct VS version
  - task: PowerShell@2
    displayName: 'Setup VS Vars'
    inputs:
      targetType: 'inline'
      script: |
        # Find VS using vswhere (works for any VS version)
        $vswhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
        if (Test-Path $vswhere) {
          $vsPath = & $vswhere -latest -products * -property installationPath
          if ($vsPath) {
            $vsDevCmd = Join-Path $vsPath "Common7\Tools\VsDevCmd.bat"
            if (Test-Path $vsDevCmd) {
              Write-Host "Running VsDevCmd from: $vsDevCmd"
              cmd /c "`"$vsDevCmd`" && set" | ForEach-Object {
                if ($_ -match "^([^=]+)=(.*)$") {
                  [Environment]::SetEnvironmentVariable($matches[1], $matches[2], "Process")
                }
              }
            } else {
              Write-Host "##[warning]VsDevCmd.bat not found at $vsDevCmd"
            }
          }
        } else {
          Write-Host "##[warning]vswhere not found"
        }

  # Cleanup appverifier from any previous runs
  - template : disable_appverifier.yml
    parameters:
      ${{ if ne(parameters.repo_root_override, '') }}:
        repo_root: ${{ parameters.repo_root_override }}

  # Use discovered cmake path for consistent behavior across architectures
  - task: PowerShell@2
    displayName: '🏗️ CMake Generate (${{ parameters.ARCH_TYPE }})'
    inputs:
      targetType: 'inline'
      script: |
        # Create build directory if it doesn't exist
        $buildDir = "$(Build.BinariesDirectory)\c"
        if (-not (Test-Path $buildDir)) {
          New-Item -ItemType Directory -Force -Path $buildDir | Out-Null
          Write-Host "Created build directory: $buildDir"
        }
        
        $cmakeArgs = @(
          "$(Build.SourcesDirectory)",
          "${{ parameters.cmake_options }}",
          "${{ variables.use_vld_option }}",
          "-DGBALLOC_LL_TYPE:string=${{ parameters.GBALLOC_LL_TYPE }}",
          "-DCMAKE_BUILD_TYPE=${{ parameters.build_configuration }}",
          '-G "Visual Studio 17 2022"',
          "-A $(cmakeArch)"
        ) -join " "
        
        Write-Host "Running: `"$(cmakePath)`" $cmakeArgs"
        Write-Host "Working directory: $buildDir"
        $process = Start-Process -FilePath "$(cmakePath)" -ArgumentList $cmakeArgs -WorkingDirectory $buildDir -NoNewWindow -Wait -PassThru
        if ($process.ExitCode -ne 0) {
          Write-Error "CMake failed with exit code $($process.ExitCode)"
          exit $process.ExitCode
        }

  # Use discovered msbuild path for all architectures (ensures native ARM64 compilation)
  - task: PowerShell@2
    displayName: '🏗️ MSBuild (${{ parameters.ARCH_TYPE }} ${{ parameters.build_configuration }})'
    inputs:
      targetType: 'inline'
      script: |
        $sln = Get-ChildItem -Path "$(Build.BinariesDirectory)\c" -Filter "*.sln" | Select-Object -First 1
        if ($null -eq $sln) {
          Write-Error "No .sln file found in $(Build.BinariesDirectory)\c"
          exit 1
        }
        Write-Host "Building $($sln.FullName) with $(msbuildPath)"
        & "$(msbuildPath)" $sln.FullName /t:restore /t:build /p:Configuration=${{ parameters.build_configuration }} /p:Platform=$(targetPlatform) /m
        if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }

  - template : start_logman.yml
    parameters:
      ${{ if ne(parameters.repo_root_override, '') }}:
        repo_root: ${{ parameters.repo_root_override }}

  # in the gate address sanitizer has problems running which are not reproducible locally, so skipping Address Sanitizer for vstest (note: ctest is perfectly fine with Address Sanitizer)
  # here's example:
  #   vstest.console will output
  # Starting test execution, please wait...
  #A total of 257 test files matched the specified pattern.
  ##[error]The active test run was aborted. Reason: Test host process crashed : AddressSanitizer: CHECK failed: asan_thread.cpp:273 "((tid())) == ((0))" (0x1, 0x0) (tid=11016)
  # [continues, with none of our code on any stack]
  # Note: VsTest doesn't support ARM64 binaries (the x64 test adapter can't discover tests in ARM64 DLLs), so skip for ARM64
  - ${{ if and(eq(parameters.FSANITIZE_TYPE, 'OFF'), and(eq(parameters.run_test_suite_without_ctest, ''), ne(parameters.ARCH_TYPE, 'ARM64'))) }}:
    - task: VSTest@2
      displayName: '🧪 VsTest - testAssemblies (no int tests)'
      inputs:
        # Some repos do not use BUILD_BINARIESDIRECTORY in cmakelists so the DLLs may be in either of the two paths below
        testAssemblyVer2: |
          $(Build.BinariesDirectory)\c\${{ parameters.build_configuration }}\**\*_ut_*.dll
          $(Build.BinariesDirectory)\${{ parameters.build_configuration }}\**\*_ut_*.dll
        runInParallel: true
        runTestsInIsolation: true
        failOnMinTestsNotRun: ${{ parameters.failOnMinTestsNotRun }}
        codeCoverageEnabled: true # Requires runSettingsFile and collect option below
        platform: 'x64'
        configuration: '${{ parameters.build_configuration }}'
        diagnosticsEnabled : true
        otherConsoleOptions: '/collect:"Code Coverage;Format=Xml"'
        runSettingsFile: '${{ parameters.repo_root_override }}/pipeline_templates/scripts/tests_native.runsettings'
        resultsFolder: '$(build.ArtifactStagingDirectory)/Test/VsTest/Results/${{ parameters.build_configuration }}${{ parameters.BUILD_SUFFIX }}'
        testRunTitle: 'VsTest Native ${{ parameters.build_configuration }}${{ parameters.BUILD_SUFFIX }}'

    # Publish code coverage results from vstest
    - task: PublishCodeCoverageResults@2
      displayName: '📰 Publish Code Coverage'
      inputs:
        summaryFileLocation: '$(build.ArtifactStagingDirectory)/Test/VsTest/Results/${{ parameters.build_configuration }}${{ parameters.BUILD_SUFFIX }}/*/*.xml'
        pathToSources: '$(Build.SourcesDirectory)'

  - ${{ if eq(parameters.run_test_suite_without_ctest, '') }}:
    - task: PowerShell@2
      displayName: '🧪 Run ctest'
      inputs:
        targetType: 'inline'
        script: |
          # --interactive-debug-mode 1 is needed to get Watson dumps when running tests under ctest
          & "$(ctestPath)" -C "${{ parameters.build_configuration }}" --output-on-failure --interactive-debug-mode 1 --no-tests=error --output-junit ctest_results_${{ parameters.build_configuration }}${{ parameters.BUILD_SUFFIX }}.xml
          if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }
        workingDirectory: $(Build.BinariesDirectory)\c

  - task: PublishTestResults@2
    displayName: '📊 Publish ctest results'
    inputs:
      testResultsFormat: 'JUnit'
      searchFolder: $(Build.BinariesDirectory)\c
      testResultsFiles: 'ctest_results_${{ parameters.build_configuration }}${{ parameters.BUILD_SUFFIX }}.xml'
      testRunTitle: 'ctest${{ parameters.BUILD_SUFFIX }}'
      buildConfiguration: ${{ parameters.build_configuration }}
      failTaskOnMissingResultsFile: true
    condition: always()

  - ${{ if and(eq(parameters.FSANITIZE_TYPE, 'OFF'), and(eq(parameters.run_test_suite_without_ctest, ''), parameters.with_app_verifier)) }}:
    - template : run_ctests_with_appverifier.yml
      parameters:
        ${{ if ne(parameters.repo_root_override, '') }}:
          repo_root: ${{ parameters.repo_root_override }}
        binary_name_suffix: ${{ parameters.binary_name_suffix }}
        ctest_tests_bin_directory: $(Build.BinariesDirectory)\c
        ${{ if ne(parameters.appverifier_skip_tests_list, '') }}:
          ctest_additional_args: "-E ${{ parameters.appverifier_skip_tests_list }}"
        test_steps:
        - task: PowerShell@2
          displayName: '🧪 Run ctest'
          inputs:
            targetType: 'inline'
            script: |
              $ctestArgs = @('-C', '${{ parameters.build_configuration }}', '--output-on-failure', '--interactive-debug-mode', '1')
              $skipTests = '${{ parameters.appverifier_skip_tests_list }}'
              if ($skipTests -ne '') {
                $ctestArgs += @('-E', $skipTests)
              } else {
                $ctestArgs += '--no-tests=error'
              }
              $ctestArgs += @('--output-junit', 'ctest_appverifier_results_${{ parameters.build_configuration }}${{ parameters.BUILD_SUFFIX }}.xml')
              & "$(ctestPath)" @ctestArgs
              if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }
            workingDirectory: $(Build.BinariesDirectory)\c

    - task: PublishTestResults@2
      displayName: '📊 Publish ctest results'
      inputs:
        testResultsFormat: 'JUnit'
        searchFolder: $(Build.BinariesDirectory)\c
        testResultsFiles: 'ctest_appverifier_results_${{ parameters.build_configuration }}${{ parameters.BUILD_SUFFIX }}.xml'
        testRunTitle: 'CTest${{ parameters.BUILD_SUFFIX }} App Verifier'
        buildConfiguration: ${{ parameters.build_configuration }}
        failTaskOnMissingResultsFile: true
      condition: always()

  - ${{ if not(eq(parameters.run_test_suite_without_ctest, '')) }}:
    - task: CmdLine@2
      displayName: '🧪 Run ${{ parameters.run_test_suite_without_ctest }}'
      inputs:
        script: '$(Build.BinariesDirectory)\${{ parameters.build_configuration }}\${{ parameters.run_test_suite_without_ctest }}\${{ parameters.run_test_suite_without_ctest }}.exe'
        workingDirectory: '$(Build.BinariesDirectory)\${{ parameters.build_configuration }}\${{ parameters.run_test_suite_without_ctest }}'

  - template : stop_logman.yml
    parameters:
      ${{ if ne(parameters.repo_root_override, '') }}:
        repo_root: ${{ parameters.repo_root_override }}

  - task: PublishPipelineArtifact@1
    displayName: 'Publish ${{ parameters.ARCH_TYPE }} ${{ parameters.build_configuration}} Artifacts'
    inputs:
      targetPath: $(Build.BinariesDirectory)
      artifactName: ${{ parameters.build_configuration}}_${{ parameters.ARCH_TYPE }}_artifacts
      parallel: true
    condition: failed()

  - template : clean_ado_folders.yml
