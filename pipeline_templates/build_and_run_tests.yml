# This is the job template for building the binaries for one configuration. It does:
# - setup the machine
# - build binaries for desired configuration
# - upload binaries artifacts for the desired configuration

parameters:
  - name: BUILD_SUFFIX
    type: string
  - name: GBALLOC_LL_TYPE
    type: string
  - name: FSANITIZE_TYPE
    type: string
  - name: build_configuration
    default: "Debug"
  - name: ARCH_TYPE
    default: "x64"
  - name: cmake_options
    type: string
    default: "-Drun_reals_check:bool=ON -Drun_unittests:bool=ON -Drun_int_tests:bool=ON -Duse_cppunittest:bool=ON -Drun_traceability:BOOL=ON -Drun_repo_validation:BOOL=ON"
  # If this parameter is specified the specified test suite will be run without invoking ctest
  - name: run_test_suite_without_ctest
    type: string
    default: ""
  # Settings to add an app verifier step for ctest
  - name: with_app_verifier
    type: boolean
    default: false
  - name: repo_root_override
    default: $(Build.SourcesDirectory)/deps/c-build-tools
  - name: binary_name_suffix
    default: ".exe"
  - name: appverifier_skip_tests_list
    type: string
    default: ""
  - name: failOnMinTestsNotRun
    type: boolean
    default: true
  # ARM64 builds are optional (continueOnError) so they don't block the gate
  - name: is_optional
    type: boolean
    default: false

jobs:
- job: build_and_run_tests_${{ parameters.BUILD_SUFFIX }}
  displayName: 'Build and run tests, build_configuration: ${{ parameters.build_configuration }}, ${{ parameters.GBALLOC_LL_TYPE}}, ARCH_TYPE=${{ parameters.ARCH_TYPE }}, FSANITIZE_TYPE: ${{ parameters.FSANITIZE_TYPE}}'
  continueOnError: ${{ parameters.is_optional }}

  variables:
    ${{ if eq(parameters.FSANITIZE_TYPE, 'ON') }}:
      use_vld_option: '-Duse_vld:bool=OFF'
    ${{ if eq(parameters.FSANITIZE_TYPE, 'OFF') }}:
      use_vld_option: '-Duse_vld:bool=ON'

  # ARM64 uses dedicated ARM pool, x64 uses standard pool
  ${{ if eq(parameters.ARCH_TYPE, 'ARM64') }}:
    pool:
      name: Azure-MessagingStore-WinBuildPoolARM
      demands:
      - msbuild
      - cmake
      - visualstudio
  ${{ else }}:
    pool:
      name: Azure-MessagingStore-WinBuildPoolVS2022_0
      demands:
      - msbuild
      - cmake
      - visualstudio

  workspace:
    clean: all

  steps:
  - checkout: self
    submodules: true
    clean: false

  # ARM64 diagnostics: detect emulation and list agent binaries architecture
  - ${{ if eq(parameters.ARCH_TYPE, 'ARM64') }}:
    - task: PowerShell@2
      displayName: '🔍 ARM64 Diagnostics - Detect emulation and list agent binaries'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "=== ARM64 EMULATION DETECTION ==="
          Write-Host ""
          
          # Current process info
          $currentProcess = [System.Diagnostics.Process]::GetCurrentProcess()
          Write-Host "Current Process:"
          Write-Host "  Name: $($currentProcess.ProcessName)"
          Write-Host "  Path: $($currentProcess.MainModule.FileName)"
          Write-Host "  PID: $($currentProcess.Id)"
          Write-Host "  PowerShell Version: $($PSVersionTable.PSVersion)"
          Write-Host "  PowerShell Edition: $($PSVersionTable.PSEdition)"
          Write-Host "  CLR Version: $($PSVersionTable.CLRVersion)"
          Write-Host ""
          
          # Environment variables
          Write-Host "Environment:"
          Write-Host "  PROCESSOR_ARCHITECTURE: $env:PROCESSOR_ARCHITECTURE"
          Write-Host "  PROCESSOR_ARCHITEW6432: $env:PROCESSOR_ARCHITEW6432"
          Write-Host "  PROCESSOR_IDENTIFIER: $env:PROCESSOR_IDENTIFIER"
          Write-Host "  NUMBER_OF_PROCESSORS: $env:NUMBER_OF_PROCESSORS"
          Write-Host ""
          
          # Registry info
          Write-Host "Windows Info:"
          try {
            $key = Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion" -ErrorAction SilentlyContinue
            if ($key) {
              Write-Host "  Build: $($key.CurrentBuild).$($key.UBR)"
              Write-Host "  Edition: $($key.EditionID)"
              Write-Host "  Product: $($key.ProductName)"
            }
          } catch { Write-Host "  Could not read registry: $_" }
          Write-Host ""
          
          # System folders
          Write-Host "System Folders:"
          Write-Host "  System32: $(Test-Path 'C:\Windows\System32') - exists"
          Write-Host "  SysWow64: $(Test-Path 'C:\Windows\SysWow64') - $(if (Test-Path 'C:\Windows\SysWow64') { 'exists (WoW64 layer)' } else { 'not found' })"
          Write-Host "  SysArm32: $(Test-Path 'C:\Windows\SysArm32') - $(if (Test-Path 'C:\Windows\SysArm32') { 'exists (ARM64 Windows)' } else { 'not found' })"
          Write-Host ""
          
          # Check IsWow64Process2 via .NET - use UInt16 instead of ushort for compatibility
          Write-Host "Emulation Detection (IsWow64Process2):"
          Add-Type -TypeDefinition @"
          using System;
          using System.Runtime.InteropServices;
          public class EmulationCheck {
            [DllImport("kernel32.dll", SetLastError = true)]
            public static extern bool IsWow64Process2(IntPtr hProcess, out UInt16 pProcessMachine, out UInt16 pNativeMachine);
            
            public static string GetMachineType(UInt16 machine) {
              switch (machine) {
                case 0: return "UNKNOWN (native process)";
                case 0x014c: return "I386 (x86)";
                case 0x8664: return "AMD64 (x64)";
                case 0xAA64: return "ARM64";
                case 0x01c4: return "ARMNT (ARM32)";
                default: return "OTHER (0x" + machine.ToString("X4") + ")";
              }
            }
            
            public static void Check() {
              UInt16 processMachine = 0;
              UInt16 nativeMachine = 0;
              bool result = IsWow64Process2(System.Diagnostics.Process.GetCurrentProcess().Handle, out processMachine, out nativeMachine);
              if (result) {
                Console.WriteLine("  Process Machine: " + GetMachineType(processMachine) + " (0x" + processMachine.ToString("X4") + ")");
                Console.WriteLine("  Native Machine:  " + GetMachineType(nativeMachine) + " (0x" + nativeMachine.ToString("X4") + ")");
                if (processMachine != 0 && processMachine != nativeMachine) {
                  Console.WriteLine("  *** RUNNING UNDER EMULATION ***");
                } else if (processMachine == 0) {
                  Console.WriteLine("  Running NATIVE (processMachine=0 means no emulation)");
                } else {
                  Console.WriteLine("  Running NATIVE (process matches native)");
                }
              } else {
                Console.WriteLine("  IsWow64Process2 returned false, error: " + Marshal.GetLastWin32Error());
              }
            }
          }
          "@
          
          try {
            [EmulationCheck]::Check()
          } catch {
            Write-Host "  IsWow64Process2 check failed: $_"
          }
          
          Write-Host ""
          Write-Host "=== AGENT FOLDER BINARY ARCHITECTURE SCAN ==="
          $agentRoot = "C:\vss-agent"
          if (-not (Test-Path $agentRoot)) {
            $agentRoot = $env:AGENT_HOMEDIRECTORY
            if (-not $agentRoot) { $agentRoot = "C:\agent" }
          }
          Write-Host "Agent root: $agentRoot"
          Write-Host "AGENT_HOMEDIRECTORY: $env:AGENT_HOMEDIRECTORY"
          Write-Host "AGENT_TOOLSDIRECTORY: $env:AGENT_TOOLSDIRECTORY"
          Write-Host "AGENT_VERSION: $env:AGENT_VERSION"
          Write-Host ""
          
          function Get-PEArchitecture {
            param([string]$FilePath)
            try {
              $stream = [System.IO.File]::OpenRead($FilePath)
              $reader = New-Object System.IO.BinaryReader($stream)
              
              # Read first 4KB
              $bytes = $reader.ReadBytes(4096)
              $reader.Close()
              $stream.Close()
              
              # Check MZ header
              if ($bytes[0] -ne 0x4D -or $bytes[1] -ne 0x5A) { return "NOT_PE" }
              
              # Get PE header offset from offset 0x3C
              $peOffset = [BitConverter]::ToInt32($bytes, 0x3C)
              if ($peOffset -lt 0 -or $peOffset -gt 3500) { return "INVALID_PE" }
              
              # Check PE signature
              if ($bytes[$peOffset] -ne 0x50 -or $bytes[$peOffset+1] -ne 0x45) { return "NOT_PE" }
              
              # Machine type at PE+4
              $machine = [BitConverter]::ToUInt16($bytes, $peOffset + 4)
              switch ($machine) {
                0x014c { return "x86" }
                0x8664 { return "x64" }
                0xAA64 { return "ARM64" }
                0x01c4 { return "ARM32" }
                default { return "UNKNOWN(0x$($machine.ToString('X4')))" }
              }
            } catch {
              return "ERROR: $_"
            }
          }
          
          # Check architecture of current PowerShell
          Write-Host "=== POWERSHELL EXECUTABLE ARCHITECTURE ==="
          $psPath = (Get-Process -Id $PID).MainModule.FileName
          $psArch = Get-PEArchitecture $psPath
          Write-Host "$psArch : $psPath"
          Write-Host ""
          
          # Find and analyze node.exe files
          Write-Host "=== NODE.EXE FILES ==="
          $nodeFiles = Get-ChildItem -Path $agentRoot -Filter "node.exe" -Recurse -ErrorAction SilentlyContinue
          Write-Host "Found $($nodeFiles.Count) node.exe files:"
          $nodeFiles | ForEach-Object {
            $arch = Get-PEArchitecture $_.FullName
            Write-Host "  $arch : $($_.FullName)"
          }
          Write-Host ""
          
          # Find externals folder and list structure with more detail
          Write-Host "=== EXTERNALS FOLDER STRUCTURE ==="
          $agentVersions = Get-ChildItem -Path $agentRoot -Directory -ErrorAction SilentlyContinue
          foreach ($ver in $agentVersions) {
            Write-Host "Agent Version: $($ver.Name)"
            $externalsPath = Join-Path $ver.FullName "externals"
            if (Test-Path $externalsPath) {
              Get-ChildItem -Path $externalsPath -Directory -ErrorAction SilentlyContinue | ForEach-Object {
                $nodeExe = Join-Path $_.FullName "bin\node.exe"
                if (Test-Path $nodeExe) {
                  $arch = Get-PEArchitecture $nodeExe
                  Write-Host "  $($_.Name): $arch"
                } else {
                  Write-Host "  $($_.Name): (no node.exe)"
                }
              }
            } else {
              Write-Host "  (no externals folder)"
            }
          }
          Write-Host ""
          
          # Agent.Listener.exe architectures
          Write-Host "=== AGENT.LISTENER.EXE FILES ==="
          Get-ChildItem -Path $agentRoot -Filter "Agent.Listener.exe" -Recurse -ErrorAction SilentlyContinue | ForEach-Object {
            $arch = Get-PEArchitecture $_.FullName
            Write-Host "  $arch : $($_.FullName)"
          }
          Write-Host ""
          
          # Sample of other executables for comparison
          Write-Host "=== SAMPLE OF AGENT EXECUTABLES (first 15) ==="
          Get-ChildItem -Path $agentRoot -Filter "*.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 15 | ForEach-Object {
            $arch = Get-PEArchitecture $_.FullName
            Write-Host "  $arch : $($_.FullName)"
          }
      continueOnError: true

  - task: BatchScript@1
    displayName: 'Git submodule update'
    inputs:
      filename: 'C:\Program Files\Git\bin\git.exe'
      arguments: 'submodule update --init --force'

  - task: BatchScript@1
    displayName: 'Git submodule clean'
    inputs:
      filename: 'C:\Program Files\Git\bin\git.exe'
      arguments: 'submodule foreach --recursive "git clean -xdff"'

  - task: BatchScript@1
    displayName: 'Git clean'
    inputs:
      filename: 'C:\Program Files\Git\bin\git.exe'
      arguments: 'clean -xdff'

  - task: BatchScript@1
    displayName: 'Setup VS Vars'
    inputs:
      filename: '"c:\Program Files\Microsoft Visual Studio\2022\Enterprise\Common7\Tools\VsDevCmd.bat"'
      modifyEnvironment: true

  # Cleanup appverifier from any previous runs
  - template : disable_appverifier.yml
    parameters:
      ${{ if ne(parameters.repo_root_override, '') }}:
        repo_root: ${{ parameters.repo_root_override }}

  - task: CMake@1
    displayName: '🏗️ CMake $(Build.SourcesDirectory) ${{ parameters.cmake_options }} ${{ variables.use_vld_option }} -DGBALLOC_LL_TYPE:string=${{ parameters.GBALLOC_LL_TYPE }} -DCMAKE_BUILD_TYPE=${{ parameters.build_configuration }} -G "Visual Studio 17 2022" -A ${{ parameters.ARCH_TYPE }}'
    inputs:
      workingDirectory: '$(Build.BinariesDirectory)\c'
      cmakeArgs: '$(Build.SourcesDirectory) ${{ parameters.cmake_options }} ${{ variables.use_vld_option }} -DGBALLOC_LL_TYPE:string=${{ parameters.GBALLOC_LL_TYPE }} -DCMAKE_BUILD_TYPE=${{ parameters.build_configuration }} -G "Visual Studio 17 2022" -A ${{ parameters.ARCH_TYPE }}'

  # ARM64 builds use msbuild directly (VSBuild@1 doesn't support ARM64)
  - ${{ if eq(parameters.ARCH_TYPE, 'ARM64') }}:
    - task: PowerShell@2
      displayName: '🏗️ Build solution (ARM64)'
      inputs:
        targetType: 'inline'
        script: |
          $sln = Get-ChildItem -Path "$(Build.BinariesDirectory)\c" -Filter "*.sln" | Select-Object -First 1
          if ($null -eq $sln) {
            Write-Error "No .sln file found in $(Build.BinariesDirectory)\c"
            exit 1
          }
          Write-Host "Building $($sln.FullName)"
          msbuild $sln.FullName /t:restore /t:build /p:Configuration=${{ parameters.build_configuration }} /p:Platform=ARM64 /m
          if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }

  - ${{ else }}:
    - task: VSBuild@1
      displayName: '🏗️ Build solution $(Build.BinariesDirectory)\c\*.sln'
      inputs:
        solution: '$(Build.BinariesDirectory)\c\*.sln'
        msbuildArgs: '/t:restore /t:build'
        configuration: ${{ parameters.build_configuration }}
        maximumCpuCount: true

  - template : start_logman.yml
    parameters:
      ${{ if ne(parameters.repo_root_override, '') }}:
        repo_root: ${{ parameters.repo_root_override }}

  # in the gate address sanitizer has problems running which are not reproducible locally, so skipping Address Sanitizer for vstest (note: ctest is perfectly fine with Address Sanitizer)
  # here's example:
  #   vstest.console will output
  # Starting test execution, please wait...
  #A total of 257 test files matched the specified pattern.
  ##[error]The active test run was aborted. Reason: Test host process crashed : AddressSanitizer: CHECK failed: asan_thread.cpp:273 "((tid())) == ((0))" (0x1, 0x0) (tid=11016)
  # [continues, with none of our code on any stack]
  # Note: VsTest doesn't support ARM64 binaries (the x64 test adapter can't discover tests in ARM64 DLLs), so skip for ARM64
  - ${{ if and(eq(parameters.FSANITIZE_TYPE, 'OFF'), and(eq(parameters.run_test_suite_without_ctest, ''), ne(parameters.ARCH_TYPE, 'ARM64'))) }}:
    - task: VSTest@2
      displayName: '🧪 VsTest - testAssemblies (no int tests)'
      inputs:
        # Some repos do not use BUILD_BINARIESDIRECTORY in cmakelists so the DLLs may be in either of the two paths below
        testAssemblyVer2: |
          $(Build.BinariesDirectory)\c\${{ parameters.build_configuration }}\**\*_ut_*.dll
          $(Build.BinariesDirectory)\${{ parameters.build_configuration }}\**\*_ut_*.dll
        runInParallel: true
        runTestsInIsolation: true
        failOnMinTestsNotRun: ${{ parameters.failOnMinTestsNotRun }}
        codeCoverageEnabled: true # Requires runSettingsFile and collect option below
        platform: 'x64'
        configuration: '${{ parameters.build_configuration }}'
        diagnosticsEnabled : true
        otherConsoleOptions: '/collect:"Code Coverage;Format=Xml"'
        runSettingsFile: '${{ parameters.repo_root_override }}/pipeline_templates/scripts/tests_native.runsettings'
        resultsFolder: '$(build.ArtifactStagingDirectory)/Test/VsTest/Results/${{ parameters.build_configuration }}${{ parameters.BUILD_SUFFIX }}'
        testRunTitle: 'VsTest Native ${{ parameters.build_configuration }}${{ parameters.BUILD_SUFFIX }}'

    # Publish code coverage results from vstest
    - task: PublishCodeCoverageResults@2
      displayName: '📰 Publish Code Coverage'
      inputs:
        summaryFileLocation: '$(build.ArtifactStagingDirectory)/Test/VsTest/Results/${{ parameters.build_configuration }}${{ parameters.BUILD_SUFFIX }}/*/*.xml'
        pathToSources: '$(Build.SourcesDirectory)'

  - ${{ if eq(parameters.run_test_suite_without_ctest, '') }}:
    - task: CmdLine@2
      displayName: '🧪 Run ctest'
      inputs:
        # --interactive-debug-mode 1 is needed to get Watson dumps when running tests under ctest: https://gitlab.kitware.com/cmake/cmake/-/merge_requests/9855/diffs?commit_id=0a4ee422c1a5a5f6e9fd8893c5029da446ae8a91#diff-content-073a6620d87def59fe2a133050c1d68204635312
        script: 'ctest -C "${{ parameters.build_configuration }}" --output-on-failure --interactive-debug-mode 1 --no-tests=error --output-junit ctest_results_${{ parameters.build_configuration }}${{ parameters.BUILD_SUFFIX }}.xml'
        workingDirectory: $(Build.BinariesDirectory)\c

  - task: PublishTestResults@2
    displayName: '📊 Publish ctest results'
    inputs:
      testResultsFormat: 'JUnit'
      searchFolder: $(Build.BinariesDirectory)\c
      testResultsFiles: 'ctest_results_${{ parameters.build_configuration }}${{ parameters.BUILD_SUFFIX }}.xml'
      testRunTitle: 'ctest${{ parameters.BUILD_SUFFIX }}'
      buildConfiguration: ${{ parameters.build_configuration }}
      failTaskOnMissingResultsFile: true
    condition: always()

  - ${{ if and(eq(parameters.FSANITIZE_TYPE, 'OFF'), and(eq(parameters.run_test_suite_without_ctest, ''), parameters.with_app_verifier)) }}:
    - template : run_ctests_with_appverifier.yml
      parameters:
        ${{ if ne(parameters.repo_root_override, '') }}:
          repo_root: ${{ parameters.repo_root_override }}
        binary_name_suffix: ${{ parameters.binary_name_suffix }}
        ctest_tests_bin_directory: $(Build.BinariesDirectory)\c
        ${{ if ne(parameters.appverifier_skip_tests_list, '') }}:
          ctest_additional_args: "-E ${{ parameters.appverifier_skip_tests_list }}"
        test_steps:
        - task: CmdLine@2
          displayName: '🧪 Run ctest'
          inputs:
            # --interactive-debug-mode 1 is needed to get Watson dumps when running tests under ctest: https://gitlab.kitware.com/cmake/cmake/-/merge_requests/9855/diffs?commit_id=0a4ee422c1a5a5f6e9fd8893c5029da446ae8a91#diff-content-073a6620d87def59fe2a133050c1d68204635312
            ${{ if ne(parameters.appverifier_skip_tests_list, '') }}:
              script: 'ctest -C "${{ parameters.build_configuration }}" --output-on-failure --interactive-debug-mode 1 -E ${{ parameters.appverifier_skip_tests_list }} --output-junit ctest_appverifier_results_${{ parameters.build_configuration }}${{ parameters.BUILD_SUFFIX }}.xml'
            ${{ else }}:
              script: 'ctest -C "${{ parameters.build_configuration }}" --output-on-failure --interactive-debug-mode 1 --no-tests=error --output-junit ctest_appverifier_results_${{ parameters.build_configuration }}${{ parameters.BUILD_SUFFIX }}.xml'
            workingDirectory: $(Build.BinariesDirectory)\c

    - task: PublishTestResults@2
      displayName: '📊 Publish ctest results'
      inputs:
        testResultsFormat: 'JUnit'
        searchFolder: $(Build.BinariesDirectory)\c
        testResultsFiles: 'ctest_appverifier_results_${{ parameters.build_configuration }}${{ parameters.BUILD_SUFFIX }}.xml'
        testRunTitle: 'CTest${{ parameters.BUILD_SUFFIX }} App Verifier'
        buildConfiguration: ${{ parameters.build_configuration }}
        failTaskOnMissingResultsFile: true
      condition: always()

  - ${{ if not(eq(parameters.run_test_suite_without_ctest, '')) }}:
    - task: CmdLine@2
      displayName: '🧪 Run ${{ parameters.run_test_suite_without_ctest }}'
      inputs:
        script: '$(Build.BinariesDirectory)\${{ parameters.build_configuration }}\${{ parameters.run_test_suite_without_ctest }}\${{ parameters.run_test_suite_without_ctest }}.exe'
        workingDirectory: '$(Build.BinariesDirectory)\${{ parameters.build_configuration }}\${{ parameters.run_test_suite_without_ctest }}'

  - template : stop_logman.yml
    parameters:
      ${{ if ne(parameters.repo_root_override, '') }}:
        repo_root: ${{ parameters.repo_root_override }}

  - task: PublishPipelineArtifact@1
    displayName: 'Publish ${{ parameters.ARCH_TYPE }} ${{ parameters.build_configuration}} Artifacts'
    inputs:
      targetPath: $(Build.BinariesDirectory)
      artifactName: ${{ parameters.build_configuration}}_${{ parameters.ARCH_TYPE }}_artifacts
      parallel: true
    condition: failed()

  - template : clean_ado_folders.yml
